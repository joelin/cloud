#云感知应用架构

##应用程序架构演进历程
应用程序体系结构跟随计算机硬件、 网络和设备从个人电脑到智能手机同步发展至今。云计算作为最新的进化力量，正在改变应用程序体系结构。要了解云计算正在怎样改变应用程序体系架构，思考在常规非云环境应用是如何架构。
###多层应用架构
比如典型的三层架构由展示层、中间层、数据层三层构建
- 展示层提供用户访问接口
- 中间层接受用户请求并执行应用业务逻辑
- 数据层提供数据存储服务

比如典型的邮件服务器架构，展示层使用outlook类似的客户端，中间层消息服务器ExchangeServer，后端的消息存储数据层；中间层通过应用协议(IMAP)提供api服务给客户端调用，中间层往往会与多个后端服务存在接口，比如邮件系统中，中间层会与用户体系的目录服务、消息存储服务、消息传输代理等有接口。

![muti-tier](muti-tier architecture.png)

三层架构词条：解释略

###虚拟环境中的多层应用架构
随着数据中心虚拟化技术的应用，越来越多的应用部署在虚拟化环境中，这样可以节省更多的成本和资源调配的时间。
对于应用程序来说，虚拟化环境几乎都是同质化的，包含应用的构造方法、配置静态数据等。由于虚拟环境可以根据需求创建和配置新的应用组件的实例，配合虚拟感知的负载技术、虚拟IP技术使扩展变得更容易，而且每层的独立扩展相对于其它层来说都是透明的。


###云应用架构
在云环境开发应用时，开发人员不一定非的改造应用的架构来适应云环境，开发人员照样可以把应用部署在云环境中，比如使用P2V方法，把物理机的应用原样迁移到虚拟机中，但是这样会妨碍应用使用云的特殊功能。比如原来的多层部署模式，耦合了依赖层的相关信息(服务信息、IP地址、web相关配置等)，这样就无法做到自动化扩展到多个虚机或私有、公共云的多个实例。如果要有效地利用云的功能，那么应用在设计架构时，就要基于云的思想和特性去考虑应用的架构，包含弹性、自助服务、多租户等等。例如下图展示的传统多层和云应用比较。

![muti vs cloud](muti-tier vs cloud.png)

###云应用架构原则
本节概述了云计算的应用程序体系结构的根本原则，表 1 列出了架构原则:它影响应用程序自身是如何组织、编码、确定最终用户怎样与之交互；表 3 总结了运维准则：它考虑了整个系统，包括如何部署应用程序的工作原理和操作，以及其他系统组件如何与之进行交互。

这些原则一般适用基于特定应用程序的上下文，并可能随着时间的推移逐步实施。在开发云知道应用程序时，表中优先级为高的原则应该优先考虑，低优先级的原则在云感知的架构中并不显得那么重要。

表 1. 架构原则

| 序号 | 原则 |描述|优先级
|--------|--------|---------|----------|
| 1|故障弹性 |弹性设计到应用程序中，而不是事后对应用的包装。这样对云计算基础设施的故障能够不中断服务的流畅处理|高|
| 2|延迟弹性 |优雅延迟的应用由于超时和中断的应用|高|
| 3|安全性|应用程序是基于生命周期的安全标准，包括内置的安全性。<br>落地的数据和传输的数据是加密的，API有认证和授权的保护|高|
| 4|位置无关|应用应动态的发现服务，而不是依赖硬编码|高|
| 5|弹性可伸缩|应用程序响应需求的级别，伸缩的需求，以及云自身特性支持|高|
| 6|SOA/组件化|应用的消费端和web服务的apis暴露提供端能够做到运行时可发现，架构结合轻量级、无状态的可扩展组件设计原则|高|
| 7|可管理性|应用可被检测，并能暴漏其度量数据和管理接口|中|
| 8|基础设施无关|应用程序不应该有任何的基础设施假设条件，应建立在抽象层的操作系统、文件系统、数据库等等之上|中|
| 9|租户定义|每个应用都应该定义一个成熟的单租户隔离和多租户共享的模式|中|
| 10|最终用户的自助服务|用户应该能够自助注册，并使用自助服务使用应用，而不是通过IT服务申请|中|
| 11|带宽感知|应设计尽量减少带宽的api和应用协议|低|
| 12|资源和成本的消耗感知|应设计尽量减少带宽、 CPU、 存储消费量和输入/输出请求的应用架构来减少费用支出|低|

接下来详细介绍云计算的应用程序的架构原则。这些原则指导应用程序是如何组织和编码，并确定最终用户如何与它进行交互。

####故障弹性

在大规模可伸缩的云计算环境中，应用程序很可能会被某些故障中断。潜在的故障包括计算的硬件故障、网络或存储物理设备故障、在应用程序组件或云服务软件故障、网络故障导致应用组件的迟钝或瞬间断链问题。为了抵御这些类型的故障，应用程序的架构必须能够无需人工干预且能够无缝处理这些故障，无论是通过用降级处理性能水平还是优雅功能降级策略。


####and so on

###云应用设计模式

此章节详细描述了特定的可应用于云应用有效云服务和现有模式的设计模式

####熔断器模式

熔断器模式被Michael Nygard提出，被NetFlix作为云服务的组成部分应用后得到长足发展。在这个设计模式里，熔断器插入请求组件和处理请求的组件之间，好像一个电路开关一样，熔断器有两个状态：打开或闭合。当熔断器闭合时，线路处于连通状态，请求可以顺畅的被转接到正常的处理组件。在一个软件版本中，请求通过被组件正常处理，熔断器打开就意味着线路出现故障，请求无法转发到正常处理的组件，意味着链路故障。熔断器的作用是检测线路和切换线路到安全的回退状态，如何决定一个熔断器的切换，其触发准则如下：
 * 请求的远端服务超时
 * 远端服务的请求队列已满，意味着该远程服务无法处理其它请求

 这些导致服务错误的共同因素到达一定阀值时，会处理该服务的熔断器切换为打开状态。
 一旦熔断器为打开状态，组件切换到备用状态。有三个备用策略：
 * 失败透明策略
   通过fallback的api方法生成一个定制的响应，例如： 返回一个cache的值或默认值。
 * 无感知的失败
   当服务调用时，如果返回值不是调用服务的关键，可以返回一个空值而不是中断服务调用
 * 快速失败处理
   如果没有敏感数据和调用服务的业务数据时，生成一个5XX的错误是有必要的；同时要求调用的服务使用对用户有意义的方式来处理错误

 理想情况下，一个组件的失败是透明的，但这并不总是可行的。
 需要注意的是，熔断器行为应区别于条件式的响应处理（“如果超时，则返回500”）:
  - 熔断器的切换往往是一段时间内的滚动窗口行为的结果，而不是单一的失败
  - 熔断器的切换和fallback行为一直延续到其被重置
  - 熔断器的状态从组件外部应该是可见的，以便其提在fallback模式下对工具提供可见性
  - 熔断器是从组件外控制的

 在Netflix的实现中，熔断器周期性的允许请求传递到处理的组件，如果处理成功，则熔断器复位，所有的请求将被允许传递到处理的组件。
 下图为熔断器处理逻辑

 ![熔断器处理逻辑](circuit-logic.png)

 Netflix在仪表盘里显示熔断器控制的相同数据的状态，为组件状态和信息提供了一个统一的视图而不是针对组件显示常规的错误码信息。
 下图为仪表盘示例

 ![仪表盘示例](circuit-view.png)

#####熔断器设计模式
  以下是熔断器设计模式里的重要几点([参考]( http://techblog.netflix.com/2012/02/faulttolerance-in-high-volume.html))：
  
  * 基本能力
    - 提高故障恢复的能力
    - 使组件故障可见
  * 在哪里使用
    - 为了消除网络延迟或虚拟机实例的故障
    - 防止级连错误蔓延和处理上游复杂的错误信息(故障透明、故障无感知)
    
####请求队列
   请求队列设计模式包含应用程序组件将请求按一个或多个队列排队处理。这些请求被可用的计算节点处理。队列作为请求方与处理服务方的缓冲以避免过载导致服务失败或处理超时。这种模式是生产者与消费者和基于队列的负载调配模式的变种。
    而不是发出所有接收的请求到一个最终端消费，通过队列请求可以负载给最终的消费端盒整个计算集群。如果某个计算节点故障，其它的工作节点将继续处理队列中的请求，这为云感知应用的高可用性提供了容错工作。
    在服务器中运行时，当管理控制服务消耗的资源使用情况时，队列还可以作为一种节流或阻止请求的机制。比如每秒从给定客户端发过来的多个请求数超过一个给定的数后执行拒绝的操作。性能计数器可以在请求排队前就处理。如果客户端的请求超过了云应用的配置阀值，它们将会被阻塞。 阻塞之后，客户端会接受一个429的http错误（太多的请求）和 重试时间。
    图5 微软的队列示例
    ![微软的队列示例](queue.png)
   
#####请求队列设计模式
   以下是请求队列设计模式里的重要几点([参考](http://www.rabbitmq.com/tutorials/amqp-concepts.html))
   
   * 基本能力
     - 提高容错性以确保高可用
     - 提高高并发的APIs性能
   * 在哪里使用
     - 管理应用的故障切换
     - 减少高并发请求APIs负载
     - 通过节流应用备用策略做到自动伸缩
   
####请求打包
   请求打包模式是API请求对应于API响应缓存。在这种设计模式中，对于高并发的API方法的多个相邻的请求被打包为一个请求。例如，显示视频的web应用程序会从视频服务端获取视频的元数据，比如视频长度。在一个常规的应用中，每个用户在访问这个页面时都将导致发起视频元数据的单独请求，如果使用请求打包，那么在给定的时间间隔，多个请求将会打包成一个请求。这不仅降低了API服务端的网络带宽和负载，还使其能够扩展支持大并发的用户请求。
   

####对象改变通知 
####服务发现
####微服务
####无状态服务
####配置服务
####授权模式

###评估应用程序的云成熟度

###运维策略

##结论

##参考

##附录


  
